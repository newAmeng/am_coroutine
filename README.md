# am_coroutine, 一个好用的协程框架

## 1.为什么要有协程

![1](./img/1.png)

在同步的模式下，服务器每发出一个请求，MySQL服务器就处理一个请求。其模式可用如下代码表示：

```c++
sync_process(void){
    read();
    parser();//数据处理
    write();
}
```

对于这种同步的方式，读操作和写操作处在同一个流程里面。如果读完数据后，写IO还没有就绪，那么就需要阻塞等待(必须是阻塞模式，如果是非阻塞模式，那么IO没有就绪，write会返回-1，这样就只进行了读操作而没有进行写操作)，直到写IO就绪后，才能进行写操作，这样就增加了等待IO就绪的时间。

![1](./img/2.png)

对于异步模式，每次有read请求到来，就先检查对应的写IO是否就绪，如果没有就绪，epoll_wait返回0，就继续处理下一个read请求。然后再检测所有的写IO，如果有写IO就绪了，那么就开始处理写IO。

```C++
func(){
    while(1){
        int nready = epoll_wait(epfd,events,EVENT_SIZE,-1);
        for(int i=0;i<nready;++i){
            if(events[i].event & EPOLLIN){
                read();
                parser();
            }else if(events[i].event & EPOLLOUT){
                write();
            }
        }
    }
}
```

对于异步的方式，我read完一次后，不需要等write完，我依然可以继续read。

## 2.协程的原语操作

![1](./img/3.png)

协程的原语操作有两个，一个是yield让出CPU，一个是resume恢复协程的运行。

yield：协程原本在运行，但因读IO没有就绪，所以让出CPU，swith到epoll_wait.

resume：当epoll_wait检测到写IO就绪的时候，就恢复某一个协程的运行。

## 3.协程的切换方式

什么时候进行协程的切换？每当遇到IO操作的时候，如果IO就绪了，那么我就处理。如果IO没有就绪，那就将其epoll_ctl到树中，然后切换到下一个协程。

协程常用的切换方式一般有三种：setjmp 和 longjmp、ucontext 上下文环境、asm code 汇编的方式。am_coroutine的协程切换采用的是汇编的方式。

协程切换的本质是对程序执行的上下文的保存和恢复，这涉及到对寄存器和协程的私有栈的操作。以x86-64为例，协程的切换需要保存的寄存器主要包括rsp、rbp、rbx、r12-r15 以及 rip。

- rsp(栈指针)：指向栈顶，即下一个可用的栈地址。在协程切换时，需要保存当前的栈指针值，以便在协程恢复的时候能够正确地访问其私有栈。
- rbp(栈底指针)：与 rsp 配合使用，用于访问栈上的数据。在协程切换时，也需要保存当前的栈底指针值。
- rbx, r12-r15：这些寄存器被视为数据寄存器，用于保存临时数据。在协程切换的过程中，这些寄存器的值也需要被保存，以确保协程恢复时的状态一致性。
- rip：程序运行的下一条指令的地址。在协程切换时，需要保存当前的指令指针值，以便在协程恢复时能够从正确的位置继续执行。

这些寄存器的保存和恢复是协程切换的核心部分，通过这些操作，可以实现协程的挂起和恢复，从而支持非阻塞IO、异步操作的功能。

![1](./img/4.png)

先将寄存器的值保存到current中，然后再将co2中保存的值加载到CPU中。

































































